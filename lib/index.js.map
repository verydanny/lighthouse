{"version":3,"sources":["../src/index.ts"],"names":["makeId","text","possible","i","charAt","Math","floor","random","length","createArr","runs","view","urls","viewRuns","flatten","url","map","run","Array","psiApiFetch","waitAmount","verbose","wait","ms","Promise","res","setTimeout","json","lighthouseResult","audits","base","auditConstants","auditList","result","Object","keys","reduce","auditResult","key","split","console","table","e","Error","getResults","arr","api","previous","curr","index","collection","apiKey","fakeUrlChange","log","chalk","red","black","bgGreen","profiler","results","module","exports"],"mappings":"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","sourcesContent":["import chalk from 'chalk'\nimport fetch from 'isomorphic-fetch'\nimport { fill, getOr, map, pick, pipe } from 'lodash/fp'\nimport flatten from 'ramda/src/flatten'\n\nexport interface IOptions {\n  runs: number,\n  wait: number,\n  view: 'mobile' | 'both' | 'desktop',\n  api?: string,\n  verbose?: boolean,\n}\n\ninterface ICreateArr<T> {\n  runs: number,\n  view: IOptions['view'],\n  urls: T[],\n}\n\nfunction makeId() {\n  let text: string = ''\n  const possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n\n  for (let i = 0; i < 6; i++) {\n    text += possible.charAt(\n      Math.floor(\n        Math.random() * possible.length\n      )\n    )\n  }\n\n  return text\n}\n\nconst createArr = <T extends any[]>({ runs, view, urls }: ICreateArr<T>) => {\n  const viewRuns =\n    view === 'both' ? ['desktop', 'mobile']\n    : view === 'mobile' ? ['mobile'] : ['desktop']\n\n  return pipe(\n    fill(0, runs, urls),\n    flatten,\n    map(url => viewRuns.map(run => `${url}&strategy=${run}`)),\n    flatten\n  )(Array(runs))\n}\n\nexport async function psiApiFetch(url: string, waitAmount: number, verbose: boolean) {\n  const wait = (ms: number) => new Promise(res => setTimeout(res, ms))\n\n  try {\n    const res = await fetch(`https://www.googleapis.com/pagespeedonline/v5/runPagespeed?url=${url}`)\n    const json = await res.json()\n\n    if (\n      json &&\n      json.lighthouseResult &&\n      json.lighthouseResult.audits\n    ) {\n      const base = json.lighthouseResult\n      const auditConstants = ['score', 'displayValue']\n      const auditList = {\n        'categories.performance| Final Score:': null,\n        'audits.interactive| TTI:': null,\n        'audits.speed-index| Speed Index:': null,\n        'audits.first-contentful-paint| First Contentful Paint:': null,\n        'audits.first-cpu-idle| CPU Idle:': null,\n        'audits.first-meaningful-paint| Meaningful Paint:': null,\n        'audits.time-to-first-byte| Time To First Byte (TTFB):': null,\n        'audits.uses-long-cache-ttl| Uses Long Cache TTL:': null,\n        'audits.estimated-input-latency| Estimated Input Latency:': null,\n        'audits.bootup-time| JS Bootup Time:': null,\n        'audits.total-byte-weight| Total Byte Weight:': null,\n        'audits.mainthread-work-breakdown| Main Thread Work Time:': null,\n      }\n\n      const result = Object.keys(auditList).reduce((auditResult, key) => ({\n        ...auditResult,\n        [key.split('|')[1]]: pipe(\n          getOr('Data not found', key.split('|')[0]),\n          pick(auditConstants),\n        )(base),\n      }), {})\n\n      if (verbose) {\n        console.table(result)\n      }\n\n      await wait(waitAmount)\n\n      return result\n    }\n\n    return 'Failed to get data'\n  } catch (e) {\n    throw Error(e)\n  }\n}\n\nasync function getResults<T extends string[]>(arr: T, waitAmount: number, api: string, verbose: boolean) {\n  return arr.reduce(async (previous, curr, index) => {\n    const collection = await previous\n    const apiKey = api !== '' ? `&key=${api}` : ''\n    const fakeUrlChange = `${curr}${apiKey}&${makeId()}=${makeId()}`\n\n    if (verbose) {\n      console.log(\n        chalk.red(`Test #${index + 1}`),\n        chalk.black.bgGreen(`Currently Running: ${curr}`)\n      )\n    }\n\n    return ({\n      ...collection,\n      [`${curr}-${index}`]: await psiApiFetch(fakeUrlChange, waitAmount, verbose),\n    })\n  }, {})\n}\n\n/**\n * @param {Object} options - `Object { runs, wait, view, api, verbose }`\n * @param {number} options.runs - How many times to run PSI test on list of urls...\n * @param {number} options.wait - How many ms to wait before running next test...\n * @param {string} [options.view=both] - Which view to run tests for: `mobile, desktop, both`...\n * @param {string} [options.api=''] - Google API key\n * @param {boolean} [options.verbose] - Output console.log after every test...\n * @param {array} urls - List of urls to provide the runner...\n */\nexport default async function profiler<T extends any[]>({\n  runs = 1,\n  wait = 2000,\n  view = 'both',\n  api = '',\n  verbose = false,\n}: IOptions, ...urls: T) {\n  // normalize runs for later\n  runs = runs * urls.length\n\n  if (verbose) {\n    console.log(\n      `Runs: ${runs}\\nWaiting: ${wait}\\nTesting View: ${view}`\n    )\n  }\n\n  const results = await getResults(\n    createArr({ runs, view, urls }),\n    wait,\n    api,\n    verbose\n  )\n\n  return results\n}\n\nmodule.exports = profiler\n"],"file":"index.js"}